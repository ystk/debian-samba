From 052dfd720dbd83c9dbfab78b42230f1aa4544781 Mon Sep 17 00:00:00 2001
From: Kai Blin <kai@samba.org>
Date: Mon, 28 Jan 2013 23:13:43 +0100
Subject: [PATCH] swat: Use additional nonce on XSRF protection

If the user had a weak password on the root account of a machine running
SWAT, there still was a chance of being targetted by an XSRF on a
malicious web site targetting the SWAT setup.

Use a random nonce stored in secrets.tdb to close this possible attack
window. Thanks to Jann Horn for reporting this issue.

Signed-off-by: Kai Blin <kai@samba.org>
---
 source3/web/cgi.c        |   39 ++++++++++++++++++++++++++-------------
 source3/web/swat.c       |    2 ++
 source3/web/swat_proto.h |    1 +
 3 files changed, 29 insertions(+), 13 deletions(-)

diff --git a/source3/web/cgi.c b/source3/web/cgi.c
index 0c8e9cb..afa2e63 100644
--- a/source3/web/cgi.c
+++ b/source3/web/cgi.c
@@ -45,6 +45,7 @@ static const char *baseurl;
 static char *pathinfo;
 static char *C_user;
 static char *C_pass;
+static char *C_nonce;
 static bool inetd_server;
 static bool got_request;
 
@@ -326,19 +327,7 @@ static void cgi_web_auth(void)
 	C_user = SMB_STRDUP(user);
 
 	if (!setuid(0)) {
-		C_pass = secrets_fetch_generic("root", "SWAT");
-		if (C_pass == NULL) {
-			char *tmp_pass = NULL;
-			tmp_pass = generate_random_str(talloc_tos(), 16);
-			if (tmp_pass == NULL) {
-				printf("%sFailed to create random nonce for "
-				       "SWAT session\n<br>%s\n", head, tail);
-				exit(0);
-			}
-			secrets_store_generic("root", "SWAT", tmp_pass);
-			C_pass = SMB_STRDUP(tmp_pass);
-			TALLOC_FREE(tmp_pass);
-		}
+		C_pass = SMB_STRDUP(cgi_nonce());
 	}
 	setuid(pwd->pw_uid);
 	if (geteuid() != pwd->pw_uid || getuid() != pwd->pw_uid) {
@@ -451,6 +440,30 @@ char *cgi_user_pass(void)
 }
 
 /***************************************************************************
+return a ptr to the nonce
+  ***************************************************************************/
+char *cgi_nonce(void)
+{
+	const char *head = "Content-Type: text/html\r\n\r\n<HTML><BODY><H1>SWAT installation Error</H1>\n";
+	const char *tail = "</BODY></HTML>\r\n";
+	C_nonce = secrets_fetch_generic("root", "SWAT");
+	if (C_nonce == NULL) {
+		char *tmp_pass = NULL;
+		tmp_pass = generate_random_str(talloc_tos(), 16);
+		if (tmp_pass == NULL) {
+			printf("%sFailed to create random nonce for "
+			       "SWAT session\n<br>%s\n", head, tail);
+			exit(0);
+		}
+		secrets_store_generic("root", "SWAT", tmp_pass);
+		C_nonce = SMB_STRDUP(tmp_pass);
+		TALLOC_FREE(tmp_pass);
+	}
+	return(C_nonce);
+}
+
+
+/***************************************************************************
 handle a file download
   ***************************************************************************/
 static void cgi_download(char *file)
diff --git a/source3/web/swat.c b/source3/web/swat.c
index 754e3ce..c63eae3 100644
--- a/source3/web/swat.c
+++ b/source3/web/swat.c
@@ -148,6 +148,7 @@ void get_xsrf_token(const char *username, const char *pass,
 	struct MD5Context md5_ctx;
 	uint8_t token[16];
 	int i;
+	char *nonce = cgi_nonce();
 
 	token_str[0] = '\0';
 	ZERO_STRUCT(md5_ctx);
@@ -161,6 +162,7 @@ void get_xsrf_token(const char *username, const char *pass,
 	if (pass != NULL) {
 		MD5Update(&md5_ctx, (uint8_t *)pass, strlen(pass));
 	}
+	MD5Update(&md5_ctx, (uint8_t *)nonce, strlen(nonce));
 
 	MD5Final(token, &md5_ctx);
 
diff --git a/source3/web/swat_proto.h b/source3/web/swat_proto.h
index 424a3af..fe51b1f 100644
--- a/source3/web/swat_proto.h
+++ b/source3/web/swat_proto.h
@@ -32,6 +32,7 @@ const char *cgi_variable_nonull(const char *name);
 bool am_root(void);
 char *cgi_user_name(void);
 char *cgi_user_pass(void);
+char *cgi_nonce(void);
 void cgi_setup(const char *rootdir, int auth_required);
 const char *cgi_baseurl(void);
 const char *cgi_pathinfo(void);
-- 
1.7.0.4

